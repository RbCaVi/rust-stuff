// cargo new <project> --lib

// makes tests
// (this is the code autogenerated by cargo new --lib)
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

// don't know about mod
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}

// and you know
// use cargo test to test it

// when the test panics, that's a failure
// except if it's a [should_panic] test?

// the assert!() macro
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller));
    }
}

// consider: assert_eq!()
pub fn add_two(a: usize) -> usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}

// message
pub fn greeting(name: &str) -> String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
}

// [should_panic]
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic] // goes after #[test]
    fn greater_than_100() {
        Guess::new(200);
    }
}

// expected substring of panic message
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}

// you can also return a result

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() -> Result<(), String> {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}

// use cargo test -- --test-threads=1 to use one thread (no parallel)
// if a test passes then it won't show any output
// if it fails it'll output stuff from stdout too
// cargo test -- --show-output will show output from passing tests too
// you can say cargo test <test> to run all tests with that as a substring of their name

// you can use #[ignore] to not run a test unless it's specifically requested
// (after #[test])
// cargo test -- --ignored to run only ignored tests
// cargo test -- --include-ignored to run all tests regardless or ignored

// test "organization" (imagine organizing anything)

// unit tests - inside the code file
// use #[cfg(test)] to only compile something for cargo test
// you are allowed to test private functions (because they're in the same scope or something)

// do unit tests make it hard to change signatures and stuff?
// is this a problem?

// integration tests - like users of the library
// each file in the tests directory in the root is a test
// i guess you still have to write #[test] before every test function
// but #[cfg(test)] isn't needed because cargo knows

// there's also doc tests
// it checks the examples in the documentation

// how to run an integration test: cargo test --test integration_test

// you can of course make modules in tests/
// but anything at the root of tests/ is treated as a test
// but you can say <module>/mod.rs instead of <module>.rs

// you can't test main.rs :(
// this is why you should make main.rs a wrapper over lib.rs